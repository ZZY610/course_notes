# 04. 数组、广义表与串

## 数组和特殊矩阵

### 数组

数组是由 $n$ （个数固定）个相同类型的数据元素构成的有限序列，每个元素称为一个数组元素。
* 下标： 数组元素的序号，除非特殊说明，**从 0 开始**。
* 维界： 下标的取值范围。

* 数组是线性表的推广。一维数组可视为一个线性表；二维数组可视为数据元素是定长线性表的线性表。

* 数组下标通常从**零**开始，矩阵下标通常从**一**开始。
### 数组存储结构
对于一维数组，有
$$loc(a_i)=loc(a_0)+n*L$$
$L=sizeof(a_i)$
对多维数组，记行下标范围是 $[0,h1]$ ，列下标范围是 $[0,h2]$ 。
计算机内存的存储空间是线性的，因此要考虑把逻辑结构上非线性的多维数组，转换成线性的存储结构的映射策略。
* 行优先，先行后列。$loc(a_{ij})=loc(a_{00})+[i*(h2+1)+j]*L$ 
* 列优先，先列后行。$loc(a_{ij})=loc(a_{00})+[j*(h1+1)+i]*L$

### 特殊矩阵的压缩存储
* 压缩存储：为多个值相同的元素分配一个存储空间，对零元素不分配存储空间。目的是为了节省空间。
* 特殊矩阵：元素分布存在一定规律的矩阵。
#### 对称矩阵

只存储**主对角线**和**下三角区**。
* 新数组大小：$1+2+...+n={n(n+1)\over2}$

* 按**行优先**将各元素存入一维数组中。

* **矩阵下标**映射**一维数组**下标
$$k=\
\begin{cases}
   {i(i-1)\over 2}+j-1 &\text i≥j \small（下三角和主对角线） \\
   {j(j-1)\over 2}+i-1 &\text i<j \small（上三角）
\end{cases}
$$

矩阵中下三角区 $a_{ij}$ 映射到数组中是第 ${i(i-1)\over 2}+j$ 个元素。因为在它之前 $i-1$ 行饱和，有 $[1+2+...+(i-1)]={i(i-1)\over 2}$ 个元素，在第 $i$ 行有 $j$ 个元素。又因为数组下标从零开始所有要减一。

* 如果按照列优先原则存储，那么下三角区 $a_{ij}$之前共有j-1列，$[n+(n-1)+...+(n-j+2)]$ ,第 j 列有$(i-j)+1$个元素。然后再减一。

#### 三角矩阵

##### 下三角矩阵
* 下三角矩阵的上三角区元素为同一常量。常量存储在数组末尾。

* 新数组大小：$1+2+...+n+1={n(n+1)\over2}+1$

* 按行优先存储，则
$$k=\
\begin{cases}
   {i(i-1)\over 2}+j-1 &\text i≥j \small（下三角和主对角线） \\
   {n(n+1)\over2}      &\text i<j \small（上三角）
\end{cases}
$$

##### 上三角矩阵

* 位于元素aij 前面的元素个数为

* 按行优先存储，则
$$k=\
\begin{cases}
   {(i-1)(2n-i+2)\over 2}+j-i &\text i≤j \small（上三角和主对角线） \\
   {n(n+1)\over2}      &\text i＞j \small（下三角）
\end{cases}
$$

#### 三对角矩阵
对矩阵中任一元素 $a_{ij}$ ，当 $|i-j|＞1$ 时，有 $a_{ij}=0$. 

* 按行优先原则，$a_{ij}$ 的前 i-1 行共 $3（i-1）-1$ 个元素，$a_{ij}$ 是 i 行第 $j-i+2$ 个元素。
  所以$a_{ij}$是第 $2i+j-2$ 个元素。

* 一维数组的第k个元素，$3（i-1）-1≤k＜3i-1$，i=$\lfloor (k+1)/3+1\rfloor$ ,$j=k-2i+3$
#### 稀疏矩阵
* 非零元素个数远少于矩阵元素个数
* 三元组：顺序存储与链式存储



## 串 *String*
### 1. 串类型的定义
串即字符串，是由零个或多个字符组成的有限序列，是数据元素为单个字符的**特殊线性表**。

* 串长：串中字符的个数（n≥0）。n=0 时称为空串（Null String） 。
* 空白串（blank string）：由一个或多个空格符组成的串。

* 子串： 串S中任意个连续的字符序列叫S的子串。
* 子串位置： 子串的第一个字符在主串中的序号。
* 字符位置： 字符在串中的序号。
* 串相等： 串长度相等，且对应位置上字符相等

::: tip 串特殊在哪里
串是一种特殊的线性表，其特殊性表现在哪里？
* 其数据元素都是字符
* 顺序存储和链式存储
* 串的长度相等且两串中对应位置的字符也相等
:::


::: tip 串的抽象数据类型定义
**ADT** String{
**Objects**: $D={ai | ai∈CharacterSet, i=1, 2,…，n, n≥0}$
**Relations**: $R1={<ai-1,ai> | ai-1,ai ∈D, i=2, …，n}$
**functions**:
* StrAssign(&T, chars) // 串赋值，生成值为chars的串T
* StrCompare(S,T) // 串比较，若S>T，返回值大于0；若S=T，返回值等于0；若S< T，返回值小于0；
* StrLength(S) // 求串长，即返回串S中的元素个数
* Concat(&T, S1, S2) // 串连接，用T返回S1＋S2的新串
* SubString(&Sub, S, pos, len) // 求S中pos起长度为len的子串
……
* Index(S, T, pos) //子串定位函数（模式匹配），返回位置
* Replace(&S, T,V) // 用子串V替换子串T    

}ADT String
:::

::: details example1
设 s =’I AM A STUDENT’, t =’GOOD’, q=’WORKER’。求：
* StrLength(s) ＝ 14 
* StrLength(t) ＝ 4
* SubString(&sub, s, 8, 7)= ‘STUDENT’
* SubString(&sub, t, 2, 1)= ‘O’
* Index(s, ‘A’)= 3  //Index(S, T, pos)  返回子串T在pos之后的位置
* Index(s, t)= 0 （ s中没有t=’GOOD’ ！）
* Replace( &s, ‘STUDENT’, q )= ’I AM A WORKER’
:::

### 2. 串的表示和实现

::: tip 注意
串与线性表的运算有所不同，是以“串的整体”作为操作对象，例如查找某子串，在主串某位置上插入一个子串等。
:::
* 串有三种机内表示方法：
    * 顺序存储
        * **定长顺序存储表示**：用一组地址连续的存储单元存储串值的字符序列，属静态存储方式。
        * **堆分配存储表示**：用一组地址连续的存储单元存储串值的字符序列,但存储空间是在程序执行过程中动态分配而得。
    * 链式存储
        * 串的块链存储表示：链式方式存储

* 定长顺序存储特点：用一组连续的存储单元来存放串，直
接使用定长的字符数组来定义，数组的上界预先给出，故
称为静态存储分配。

* 堆分配存储特点：仍用一组连续的存储单元来存放串，
但存储空间是在程序执行过程中动态分配而得。

#### 王道书中的表示方法：

* 使字符**数组的下标**（物理位序）和**逻辑位序**保持一致。
    * 具体的方法为：数组第一位（`ch[0]`）置空不用，最后一位存放`length`。
    * 以下提到 “第一位” 指的是字符串**第一个字符**，在存储结构上是 `ch[1]` 而不是 `ch[0]`。
    * 指针 `j` 移到第 `i` 位，实际上它指的是 `ch[j+1]` ，它指的是逻辑位序。
### 3. 串的模式匹配算法
::: tip
定位问题称为串的**模式匹配**(*Pattern Matching*)，即子串定位运算，它是串处理系统中最重要的操作之一。
典型函数为Index(S,T,pos).
:::


* 算法目的：确定主串中所含子串（模式串）第一次出现的位置（定位）

* 算法应用：搜索引擎、拼写检查、语言翻译、正则表达式

* 算法种类：BF（brute-force）、KMP算法（速度快）

#### 1. BF算法
* 古典的、经典的、朴素的、穷举的

简而言之，就是将主串`S`中所有长度与**模式串`T`**相等的**子串**与模式串进行比对，直到找到匹配的字串，或所有子串都不匹配为止。

* BF算法设计思想：
    * 分别用计数指针 **i** 和 **j** 指示`S`和`T`当前正待比较的字符。
    * 将主串`S`的第`pos`个字符和模式`T`的第1个字符比较，若相等，继续逐个比较后续字符；
      若不等，从主串`S`的下一字符（pos+1）起，重新与`T`第一个字符比较。即把 `T` 后移一位。
    * 直到主串`S`的一个连续子串字符序列与模式`T`相等。返回值为`S`中与`T`匹配的子序列第一个字符的序号，即匹配成功。否则，匹配失败，返回值 0 .

```c
//BF朴素模式匹配算法
int BFindex(SString S, SString T){
	int i=1,j=1;
	while(i<=S.length && j<=T.length){
		if(S.ch[i] == T.ch[j]){
			++i;++j;}
		else{
			i=i+j-2;
			j=1;
		}
	}
	if(j>T.length)
		return i-T.length;
	else 
		return 0;
}
```

* BF算法的时间复杂度：
    * 若n为主串长度，m为子串长度，最多匹配n-m+1个子串。
    * 串的BF匹配算法最坏的情况下需要比较字符的总次数为 (n-m+1)*m＝O(n*m)
::: warning 最坏的情况
s = “aaaaaaaaaaaaaaaba”
t = “aaaaaaaba”
每个子串都要匹配m个字符，共n-m+1个子串，故O(f(n))=O((n-m+1)m＝O(nm))
:::

#### 2. KMP算法
由三个人联合提出。该算法的核心思想是：
当匹配失败时，利用已经**部分匹配**这个有效信息，保持 `i` 指针不回溯，通过修改 `j` 指针，让模式串尽量地移动到有效的位置。

所以重点在于：当某一个字符与主串不匹配时，我们要搞清楚知道 `j` 指针要移动到哪、也就是前哪几个字符不再需要匹配了？

其实用一句话就可以概括KMP算法：在 `j` 位置发生失配时，指针 `j` 要移动到位置 `k` ， `k` 之前的所有字符（共 `k-1` 个）和 `j` 位置前的 `k-1` 个字符是一样的；如果找不到这样的位置 `k` ，就把 `j` 移动到第一位。

::: tip example
$S$: ABAC??????
$T$: ABAD
当第四个字符失配，应当令 `j=2`，`i` 不变。
:::

* 实际上是对BF算法的优化：
    * 失配后，应移动的距离，与目标串无关，**只与模式串前j个字符有关**。
    * 当模式T中第j个字符失配时，应该用T中第k个字符，与刚才失配的位置对齐，继续比较。j-k等于模式应移动的距离
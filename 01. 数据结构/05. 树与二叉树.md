# 05. 树与二叉树
树是一种常见的数据结构，广泛应用于计算机的多个领域：操作系统，图形学，数据库，计算机网络等。
* 逻辑结构：树形结构是非线性结构，结点之间有分支、具有**层次**关系.
![Img](./FILES/05.%20树与二叉树.md/img-20220721100145.png)

## 概念

### 1. 树 *Tree*
* 定义1： 树由结点及连接结点的边构成。
    *  仅有一个根结点; 
    *  除根结点外，其他每个结点都与其**唯一**的父结点相连; 
    *  从根结点到其他每个结点都**有且仅有一条**路径; 
    *  如果每个结点最多有两个子结点，我们就称这样的树为二叉树。

* **定义2**（递归定义）：

    * 一棵树要么为空，要么由一个根结点和零棵或多棵子树构成，子树本身也是一棵树。
    若$n = 0$，称为空树;
    若$n > 0$，则它满足如下两个条件:
        * 有且仅有一个特定的称为根(Root)的结点;
        * 其余结点可分为 $m (m≥0)$ 个互不相交的有限集$T_1,T_2,T_3,....T_m$，其中每一个集合本身又是一棵树，并称为根的**子树**( SubTree )。
:::col
$$树(Tree) 是 n(n≥0) 个结点的有限集.$$
:::
### 2. 结点、边、路径
* **结点**：数据元素存储结构，是树的基础部分。结点也可以带有附加信息，我们称作“有效载荷”。
![Img](./FILES/05.%20树与二叉树.md/img-20220721100651.png)

* **边**：边是树的另一个基础部分。
    * 每条边恰好连接两个结点，表示结点之间具有关联，边具有出入方向。
    
    * 每个结点（除根结点）**有且仅有一条**来自另一结点的**入边**。 
    
    * 每个结点可以有多条连接到其它结点的**出边**。

    * 一棵树的**边数**等于结点总**度数**。 
![Img](./FILES/05.%20树与二叉树.md/img-20220721100732.png)

* **根结点**：是树中唯一没有前驱结点（没有入边）的结点。



* **路径**：由边依次连接的有序结点列表。边、路径是**有向**的，只能**从上往下**.
![Img](./FILES/05.%20树与二叉树.md/img-20220721100813.png)

    * **路径长度**：该路径经过的边数.

### 3. 结点之间的关系
* **祖先**：根结点到某一结点的唯一路径上的任一结点，称为该结点的**祖先**结点。
    * 某一结点**所有子树**上的结点，称为该结点的**后代**或子孙。

* **子结点**（孩子结点）：
    * 入边均来自于同一结点的若干结点，称为这个结点的**子结点**，也称**孩子**。
    * 结点的子树的根结点称为该结点的**孩子**。
    ![Img](./FILES/05.%20树与二叉树.md/img-20220721100900.png)

* **父结点**（双亲结点）：一个结点是其所有子结点的父结点。结点的**直接前驱**是它的父结点.
![Img](./FILES/05.%20树与二叉树.md/img-20220721100919.png)

    * **子树**：一个父结点及其**所有后代**的结点和边构成一棵子树。
    ![Img](./FILES/05.%20树与二叉树.md/img-20220721100952.png)

* **兄弟结点**：具有同一父结点的结点称为兄弟结点。
![Img](./FILES/05.%20树与二叉树.md/img-20220721100919.png)

    * 堂兄弟结点：双亲在同一**层**的结点。

* **叶子结点**：没有子结点的结点称为叶结点。
![Img](./FILES/05.%20树与二叉树.md/img-20220721101010.png)

* **分支结点**：拥有子结点的结点称为分支结点。

### 4. 结点的属性
* **度**：结点拥有的子结点（孩子）数（也即子树个数）称为该结点的 **度** 。树中结点最大度数称为 **树的度** 。
    * 分支结点（非终端结点）：度不为零的结点。
    * 叶子结点（终端结点）：度为零的结点。

* 结点的深度、高度、层次
    * **层次**：结点 $n$ 的层次是从根结点到 $n$ 的唯一路径长度。
        * 从根结点开始，根结点为 **第1层**，其子结点为第2层，以此类推。 
    ![Img](./FILES/05.%20树与二叉树.md/img-20220721101020.png)

    * 深度：从根结点开始，自顶向下累加的路径长度.
    
    * 高度：从 **最深** 叶子结点开始，自底向上累加的长度    

        * 树的高度：树中所有结点的最大层次为树的高度。

### 5. 有序树与无序树
* 有序树：树中结点各 **子树** 从左至右有次序，不能互换位置。
* 无序树：树中结点各 **子树** 从左至右无次序，互换位置仍是同一棵树。

### 6. 森林
$$m(m≥0)棵互不相交的树的集合。$$
* 把树的根结点删除就成为森林。给森林的各树加上同一个双亲结点就成为树。
* 树是特殊的森林（只有一棵树的森林）。森林不一定是树。


### 树的性质

* 树的结点数等于
    * 边数加 1.（除根结点每个结点都对应一条入边）
    * 所有结点度数之和加 1.
        （$n=0*n_0+1*n_1+2*n_2+...+1\\=n_0+n_1+n_2+...n_m$）

* 度为 $m$ 的树中第 $i$ 层上至多有 $m^{i-1}$ 个结点（$i≥1$）。

* 高度为 $h$ 的 $m$ 叉树最多有 ${m^h-1\over m-1}$ 个结点。根据等比数列求和公式得出。

* 具有 $n$ 个结点的 $m$ 叉树的最小高度为$\lceil log_m(n(m-1)+1) \rceil$

## 二叉树
### 1. 概念
:::col
$$每个结点至多只有两棵子树的树.$$
:::

* 二叉树的递归定义：二叉树是$n(n≥0)$个结点的有限集，它或者是空集$(n = 0)$，或者由一个根结点及两棵互不相交的、分别称作这个根的 **左子树** 和 **右子树** 的二叉树组成。
* 二叉树是有序树，左右次序不能颠倒。
* 二叉树只有五种基本形态：空二叉树、只有根结点、只有左子树、只有右子树、左右子树都存在。

::: tip 有序树与二叉树的区别
严格说来二叉树并不是有序树、甚至也不是“**树**的特殊情况”。
* 二叉树结点的子树要严格区分左右子树，即使只有一棵子树也要进行区分它是左子树还是右子树。
* 有序树的结点的孩子的次序，是相对其他孩子而言的，当某结点只有一个孩子时，就无需区分其左右次序。
* 即：二叉树的结点次序是固定的，可以说它是**空二叉树**，但不是没有次序；而有序树的结点次序是相对别的结点来说的，没有别的结点时就无所谓左右。
* 树的概念术语对二叉树通用。
:::
| 度为m的树和m叉树的区别{colspan=2}|
| 度为m的树 | m叉树 |
| -- | -- |
| 任意结点的度≤ m（最多m个孩子） | 任意结点的度≤ m（最多m个孩子） |
| **至少**有一个结点度= m | 允许所有结点的度都＜ m |
| 一定是非空树，至少m+1个结点 | 可以是**空树** |

### 2. 几种特殊的二叉树
#### 1. 满二叉树
高度为 $h$ ，含有 $2^h-1$ 个结点的二叉树.
* 每层都含有最多的结点、只有最后一层有叶子结点。
* 除叶子结点之外每层结点度数都是2.
* 从 1 开始按层序给二叉树进行编号，从上到下、从左到右。
    * 结点 `i` 的编号左孩子是 `2i` ，右孩子是 `2i+1` ，双亲是 $⌊ i/2 ⌋$ .

#### 2. 完全二叉树
高为 $h$，有 $n$ 个结点的二叉树，当且仅当其每个结点都与高度为 $h$ 的满二叉树中编号为$1～n$的结点一一对应时,称为完全二叉树.

* 即在满二叉树中，从最后一个结点开始连续去掉任意个结点，得到的都是完全二叉树。
* 满二叉树也是完全二叉树。
* 最多只有**一个**度为 1 的结点。而且它的孩子一定是**左孩子**。
* **若$i≤⌊ n/2 ⌋$则 $i$ 是分支结点，否则是叶子结点。**
* 叶子结点只分布在层次最大的**两层**上。

#### 3. 二叉排序树
* 左子树所有结点的关键字均==小于==根结点关键字。
* 右子树所有结点的关键字均==大于==根结点关键字。
* 左右子树都是二叉排序树。

#### 4. 平衡二叉树
* 树上任一结点的左子树和右子树深度之差不超过 $1$.

### 3. 二叉树的性质
1. 非空二叉树上**叶子结点**数等于**度为 2 的结点**数加 1 ，即$n_0=n_2+1$ 

    除根节点外所有节点总数（除根节点外所有节点都有一个分支进入，就是都有父节点）：n-1=n1+2n2
    所有节点：n=n0+n1+n2

$$n_0+n_1+n_2=n_1+2n_2+1$$

2. 非空二叉树上第 $k$ 层上至多有 $2^k−1$ 个结点 $（k≥1）$

3. 高度为 $h$ 的二叉树至多有 $2^h-1$ 个结点 $（h≥1）$

#### 完全二叉树

1. **双亲结点编号与孩子结点编号的关系**：一棵完全二叉树 ，有n个结点，若按照结点层次从左到右给其编号 ，则对于任意结点$i$有

$$\begin{cases}
   i=1 &\text{ 根结点 }  \\
   i≠1 且i≤n &\text{i的双亲为⌊i/2⌋}\\
    2i＞n &\text{ i无左孩子 }  \\
    2i≤n &\text{ 2i为i左孩子 }  \\
    2i+1＞n &\text{ i无右孩子 }  \\
    2i+1≤n &\text{ 2i+1为i的右孩子 }  \\
\end{cases}$$


2. **度数不同的结点**之间的数量关系：对于完全二叉树，可以由的结点数 $n$ 推出度为0、1和2的结点个数为$n_0、n_1和n_2$
    * 完全二叉树最多只有一个度为1的结点，即 $n_1=0或1$
    * $n_0=n_2+1$ 
    * 若完全二叉树有 $2k$ 个（偶数)个结点，则必有$n_1=1，n_0= k,n_2= k-1$
      若完全二叉树有 $2k-1$ 个（奇数）个结点，则必有$n_1=0, n_0= k, n_2 = k-1$

3. **高度与结点数的关系**：具有$n$个（$n>0$）结点的完全二叉树的高度为 $\lceil log_2(n+1)\rceil$或$\lfloor log_2n \rfloor +1$。
    * 高为 $h$ 的满二叉树共有 $2^h−1$ 个结点.
    * 高为 $h-1$ 的满二叉树共有 $2^{h−1}-1$ 个结点.
    * $$2^h−1 ＜n≤ 2^{h−1}-1\\
        2^{h−1}＜n≤2^h\\
        h-1＜log_2(n+1)≤h\\
        h=\lceil log_2(n+1) \rceil
      $$

    * 高为 $h-1$ 的满二叉树共有 $2^{h−1}-1$ 个结点.
    * 高为 $h$ 的完全二叉树**至少**有 $2^{h−1}$ 个结点。**至多**有${2^h-1}$个结点。
        $$    2^{h−1}≤n＜2^h\\
        h-1≤log_2n＜h\\
        h=\lfloor log_2(n) \rfloor+1
        $$

#### 满二叉树
1. 若高度为 $h$，则结点数为$2^{h}-1$；第 $i$ 层结点数为$2^{i-1}$.
2. 若叶子结点数为$n_0$，则总结点数$n=2n_0-1$.
3. 若结点数为$n$，则
    * $n0={n+1\over2}$. $n_2={n-1\over2}$.
    * 高度$h=log_2n+1$.
### 4. 二叉树的存储

#### 顺序存储
* 直接按照编号存储，适合存储满二叉树和完全二叉树。树中结点序号可以反映结点之间的逻辑关系。
* 对于普通的二叉树，必须分配一棵相同深度的完全二叉树的空间，添加一些空结点，使每个结点与完全二叉树上的结点相对照。空间利用率低下。

#### 链式存储

* n个结点的二叉链表共有n+1个空链域。
$$n=n_0+n_1+n_2,n_0=n_2+1\\\downarrow\\n_1+2n_0=n+1$$
### 5. 二叉树的遍历

1. 遍历定义：顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次(又称周游)。
2. 遍历目的：得到树中所有结点的一个线性排列。
3. 遍历用途：是树结构增、删、改、查和排序等运算的前提和基础。

#### 递归遍历方法
* 先序遍历：根左右

        若二叉树为空，则空操作；
        若二叉树非空，
            访问根结点D
            先序遍历左子树L
            先序遍历右子树R
        
    ```c
    Status PreOrder(BiTree T){
        if(T==NULL) return OK;//空二叉树
        else{
        visit(T);//访问根结点
        PreOrder(T->lchild);//递归遍历左子树
        PreOrder(T->rchild);//递归遍历右子树
        }
    ```

* 中序遍历：左根右
    
        若二叉树为空，则空操作；
        若二叉树非空，
            中序遍历左子树L
            访问根结点D
            中序遍历右子树R
    ```c
    Status InOrder(BiTree T){
        if(T==NULL) return OK;//空二叉树
        else{
        InOrder(T->lchild);//递归遍历左子树
        visit(T);//访问根结点
        InOrder(T->rchild);//递归遍历右子树
        }
    ```
* 后序遍历：左右根

        若二叉树为空，则空操作；
        若二叉树非空，
            后序遍历左子树L
            后序遍历右子树R
            访问根结点D
    ```c
    Status PostOrder(BiTree T){
        if(T==NULL) return OK;//空二叉树
        else{
        PostOrder(T->lchild);//递归遍历左子树
        PostOrder(T->rchild);//递归遍历右子树
        visit(T);//访问根结点
        }
    ```
不难看出，除去 `visit` 访问函数，这三个递归算法的代码逻辑，或者说访问路径是==完全相同==的。

它们之间的不同在于访问根结点是在遍历左、右子树之前还是之后。

每个结点经过三次，第1、2、3次经过此结点时访问，就是先、中、后序遍历。
时间复杂度为 $O(n)$ .空间复杂度为 $O(n)$ .

#### 非递归遍历方法

* 若二叉树的各值不相同，则其结点的先、中、后序序列均唯一。
* 由二叉树的**先、中序序列**，或**后、中序序列**可以确定唯一一棵二叉树。
    * 先找 **先** 或 **后**序 ，确定每棵子树的根结点，再根据中序确定左右孩子结点。


#### 线索二叉树

![Img](./FILES/05.%20树与二叉树.md/img-20220802094239.png)

引入线索二叉树是为了加快查找结点在某种遍历中的前驱或后继的速度。

* 遍历二叉树是按照一定规则访问二叉树的结点，得到一个线性序列。使得除首尾结点都有一个前驱和一个后继。

* 普通的二叉链表的缺点：
    * 不能直接得到某结点在**某种遍历**中的前驱和后继。必须完整遍历一次。
    
* 线索二叉树：
    * 利用二叉链表中的 $n+1$ 个空链域，存放指向前驱和后继的指针。这样的指针称为**线索**。
        * 无左子树，令`lchild`指向前驱
        * 无右子树，令`rchild`指向后继
    * 增加两个标志位 `ltag` 和 `rtag` ，用来指示指针域指向的是左右孩子，还是前驱或后继。
        * `tag==0`，指向孩子；`tag==1`，指针是线索   

    ```c
    typedef struct ThreadNode{
        Elemtype data;                   	//数据域
        struct ThreadNode *lchild,*rchild;	  //左右孩子指针	
        int ltag,rtag;						//左右标志位
    }ThreadNode,*ThreadTree;

    ThreadNode *pre = NULL;

    void InThread(ThreadTree T, ThreadNode *pre){//pre指向当前访问结点的前驱
        if(T!=NULL){
            InThread(T->lchild,pre);//中序遍历左子树

            //访问根结点
            if(T->lchild == NULL){//左子树为空，建立前驱线索
                T -> lchild = pre;
                T -> ltag = 1;
            }
            
            if(pre != NULL && pre->rchild == NULL){
                pre->rchild = T;//建立前驱结点的后继线索
                pre->rtag=1;
            }
            pre = T;  
            
            InThread(T->rchild,pre);
        }
    }
    ```

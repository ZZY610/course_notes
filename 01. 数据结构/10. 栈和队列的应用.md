# 栈和队列的应用
> ### talk is cheap,show me the code!

## 1. 栈的应用
1. 调用函数或子程序非它莫属；

2. 递归运算的有力工具；

3. 用于保护现场和恢复现场；
    * ctrl z都会用到栈

4. 简化了程序设计的问题。

### 进制转换

十进制整数 $N$ 向 $d$ 进制的转换是计算机实现计算的基本问题。

* 转换方式：除以 $d$ 取倒余
$$N=(N \space div \space d) × d + n \space mod \space d$$
```c
void conversion (SqStack S, int N, int d) {
	//S是栈实例，N是十进制数，d是待转换的进制
	InitStack(S); 
	
	printf("%d转换后的值是：",N);
	while (N) {
		Push(S, N % d);
		N = N/d;
	}
	
	while (!StackEmpty(S)) {
		int e;
		Pop(S,e);
		printf ( "%d", e );
	}
}


int main(){
	SqStack S;
	conversion(S,19,2);//19转换为2进制
}
```


### 括号匹配
检验含两种括弧的表达式中括弧匹配的正确性。

* 括号嵌套顺序是随意的。如
    * $([]()) \space\space、[([][])]$正确
    * $(()、([)]\space\space、((]$错误（数量不匹配、种类不匹配、数量种类都不匹配）

* 算法的设计思想：
    * 凡出现左括弧，则进栈；
    
    * 凡出现右括弧，首先检查栈是否空？
    若栈空，则表明该“右括弧”多余
    否则和栈顶元素比较，
    若相匹配，则“左括弧出栈”
    否则表明不匹配
    
    * 表达式检验结束时，
    若**栈空**，则表明表达式中匹配正确
    否则表明“左括弧”有余。匹配失败。

一句话，**先入栈后匹配，后入栈先匹配**。

```c
//括号匹配
bool BracketsCheck(SqStack S,char *str){
	InitStack(S);
	int i=0;		char e;
	while(str[i]!='\0'){
		switch (str[i]) {
		case '(': Push(S,'(');break;
		case '[': Push(S,'[');break;
		case ')': Pop(S,e);
				if(e!='(') return false;
			break;
		case ']':Pop(S,e);
				if(e!='[') return false;
			break;
		default:
			break;
		}//switch
		i++;
	}//while
	if(!StackEmpty(S)){
		printf("括号不匹配\n");
		return false;
	}
	else{
		printf("括号匹配\n");
		return true;
	}
}
```


### 表达式求值
栈应用的典型案例。

#### 表达式构成与转换
* 中缀表达式
    * 操作数 *operand*：常数和变量
    * 运算符 *operator*：算术运算符、关系运算符、逻辑运算符
    * 界限符 *delimiter*：左右括弧、表达式结束符   

* 后缀表达式（逆波兰表达式 Reverse Polish notation）
    * 不用界限符无歧义表达运算顺序。
    * 运算符放在两个操作数的后面

* 前缀表达式（波兰表达式 Polish notation）
    * 运算符放在两个操作数的前面   

| 中缀 | 前缀 | 后缀 |
| -- | -- | -- |
| a+b | +ab | ab+ |
| a+b-c | -+abc | `abc-+` `ab+c-` |
| a+b-c*d | -+ab*cd | ab+cd*- |
| a+b*(c-d) | +a*b-cd | abcd-*+ |

#### 表达式转换

* 中缀转后缀手算方法
    * 确定中缀表达式中各运算符的**运算顺序**，这就是后缀表达式中运算符的出现顺序。
        * 因为加法和减法同级、乘法和除法同级，运算顺序往往不唯一。但因为算法的唯一性，计算机只选其中一种。采取**左优先原则**确定运算顺序。
    * 选择下一个运算符，按照`左操作数 右操作数 运算符` 的方式组合成一个新的**操作数**。
    * 继续二直到运算符处理完毕。

* 中缀转后缀机算方法
        初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。从左到右处理各个元素，直到末尾。可能遇到三种情况:
        1. 遇到==操作数==。直接加入后缀表达式。
        2. 遇到==界限符==。遇到 `(` 直接入栈; 遇到 `)` 则依次弹出栈内运算符并加入后缀表达式，直到弹出 `(` 为止。注意: `(` 不加入后缀表达式。
        3. 遇到==运算符==。依次**弹出栈中优先级高于或等于**当前运算符的所有运算符，并加入后缀表达式，若碰到“(”或栈空则停止。之后再把当前运算符入栈。*/优先级高于+-
        按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。2!


#### 表达式计算

* 后缀表达式计算方法：
    * 从左往右扫描，每遇到一个运算符，让运算符前面两个操作数执行运算，然后合并为一个操作数。

* 用栈实现后缀表达式的计算
        1. 从左至右扫描所有元素
        2. 若扫描到操作数则压栈，继续执行1，否则执行3.
        3. 若扫描到操作符，则弹出两个栈顶元素（先出栈的是**右操作数**）并执行运算，结果压回栈顶，执行1.
        4. 如果表达式合法，最终栈中只剩下计算结果。

#### 中缀表达式求值（算符优先算法）
> 由运算符优先级确定顺序的对表达式求值的算法


为了实现**中缀表达式**求值。需要设置两个栈:
* 运算符栈`OPTR`，用于寄存运算符。
* 操作数栈`OPND`，用于寄存运算数和运算结果。
实际上就是结合了栈中缀转后缀、栈后缀求值两个算法。

求值的处理过程是自左至右扫描表达式的每一个字符
* 当扫描到的是运算数，则将其压入栈`OPND`,
* 当扫描到的是运算符时
    * 若这个运算符比`OPTR`栈顶运算符的优先级高，则入栈`OPTR`,继续向后处理
    * 若这个运算符比`OPTR`栈顶运算符优先级低或相同，则从`OPND`栈中弹出两个运算数，从栈`OPTR`中弹出栈顶运算符进行运算，并将运算结果压入栈`OPND`。
    * 弹出一个运算符意味着这个运算符已经可以确定生效了。
* 继续处理当前字符，直到计算完毕或遇到结束符为止。


### 栈在递归中的应用
* 如果一个函数、过程或数据结构在定义中应用了它自身，我们称它为**递归**定义的。

#### 函数调用栈
调用函数时，系统会为调用者构造一个由参数表和返回地址组成的活动记录，并将记录压入系统提供的栈中，若被调用函数有局部变量，也要压入栈中。

* 函数调用的特点：最后被调用的函数最先执行结束。
* 函数调用时，要用一个栈存储：
    * 调用返回地址
    * 实参
    * 局部变量

## 2. 队列的应用

### 层次遍历

为了安排好需逐层处理的问题的解决顺序，用队列存储下一步的处理顺序。

1. 根节点入队
2. 若队空则处理完毕，否则继续3
3. 队列中第一个节点出队，将其左右孩子结点（若存在）入队，返回2

### 操作系统的应用

* FCFS先来先服务策略。
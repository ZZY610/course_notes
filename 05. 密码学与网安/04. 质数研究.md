# 04. 质数研究
## 整除理论
### 1. 整除性和带余除法
* **整除性**（Divisibility）
    * 设 $a,b$ 均为整数，若存在某个整数 $m$ 使得 $a=mb$ 成立，则称非零数 b **整除**（divides） a 。
    * 换言之，若 b 除 a 没有余数，则称 b 整除 a 。
    * b 整除 a 通常用 $b|a$ 来表示，b是a的一个==因子==。
* 整数整除的性质
    * 若 a|1，则 a=±1
    * 若 a|b 且 b|a ，则a=±b
    * 任何不等于零的数都整除0
    * 若 a|b 且 b|c ，则 a|c
    * 对任意整数m、n，若 b|g 且 b|h ，则$b|(mg+nh)$
* 带余除法
    * 对给定的任意一个正整数 $n$ 和任意整数 $a$ ，若用 $n$ 除 $a$ ，得到整数 $q$ 和整数余数 $r$ ，且满足以下关系式：
    $$a=qn+r,0≤r＜n,q=⌊a/n⌋$$
    $⌊x⌋$表示小于等于 $x$ 的最大整数
    * 对于负数a，n也成立。
    * ==**余数的符号和除数同号**==

:::col example
* 5 / 3
    * 5 = 3 * ⌊5/3⌋ + 2
    * 5 mod 3 = 2
* 5 / -3
    * 5 = -3 * ⌊5/-3⌋ - 1
    * 5 mod -3 = -1
* -5 / 3
    * -5 = 3 * ⌊-5/3⌋ + 1
    * -5 mod 3 = 1
* -5 / -3
    * -5 = -3 * ⌊-5/-3⌋ - 2
    * -5 mod -3 = -2
:::

### 2. 欧几里得算法
欧几里得算法可以快速的求出两个正整数的最大公因子（Greatest Common Divisor, gcd）.
整数的最大公因子（也称最大公约数）用gcd来表示，是两个或多个整数共同具有的最大约数。
#### 拓展欧几里得算法
欧几里得算法用于求取整数a,b的最大公因数gcd(a,b)，基于$gcd(a,b)=gcd(b,a mod b)$成立。拓展的欧几里得算法用于求取a*x+b*y=gcd(a,b)的整数解(x,y)。

```python
def extendgcd(a,b):            #返回一个集合：(x,y,d)满足ax+by=d
    if b == 0:
        return (1,0,a)
    else:
        (x,y,d)=extendgcd(b,a%b)
        x,y=y,(x-(a//b)*y)#x-(a//b)*y即为x mod y
        return (x,y,d)
```
当算法进行到最后一步，即 $a=d，b=0$ 时，必然有 $(x,y)=(1,0)$ 满足 $a*1+b*0=d$ 。此即为回溯的起始点。

考察回溯过程中上下两层的关系。有：
$$a * x1 + b * y1 = gcd(a,b)\\
b * x2 + (a\%b) * y2 = gcd(b,a\%b)$$

d= gcd(a,b) = gcd(b,a%b) 算法中每一步返回值都满足d=ax+by

得：a * x1 + b * y1 = b * x2 + (a%b) * y2
其中a%b换为a-(a/b)*b。
得：a * x1 + b * y1 = b * x2 + (a - (a / b) * b) * y2
                =b * (x2 - (a / b) * y2) + a * y2
                  =a * y2 + b * (x2 - (a / b) * y2)
得到：
X1=y2, y1=(x2 - (a / b) * y2)
得到方程b * x2 + (a%b) * y2 = g(b,a%b) 的解x2, y2，就能得到方程a * x1 + b * y1 = g(a,b) 的解x1,y1。


在RSA算法中，拓展欧几里得算法用于求取e的关于模φ(n)的逆元d。
即令e*d mod φ(n)=1，求d。 
令e*x+φ(n)*y=gcd(e,φ(n))=1          #φ(n)与e互质
该式正是拓展欧几里得算法公式。求取x。
等式两边同时模φ(n)，得e*x mod φ(n)=1。
即x就是我们要求的私钥d。


### 3. 模运算
模运算常用于计算离散数学中的 **同余** 关系。模运算也被称为取模运算，用符号 `%` 表示，其基本概念是在一个模数n的范围内对数进行运算。

对于给定的整数a和正整数n，模运算a mod n的结果是除法所得的余数。例如，17 mod 5等于2，因为17除以5的余数是2。

模运算有以下性质：

1.  加法的模运算满足结合律和交换律，即(a+b) mod n = ((a mod n) + (b mod n)) mod n，a mod n = b mod n，则(a+c) mod n = (b+c) mod n。
2.  减法的模运算满足结合律和交换律，即(a-b) mod n = ((a mod n) - (b mod n) + n) mod n，a mod n = b mod n，则(a-c) mod n = (b-c) mod n。
3.  乘法的模运算满足结合律和交换律，即(a×b) mod n = ((a mod n) × (b mod n)) mod n。
4.  除法的模运算不满足结合律和交换律，但是有除法的模逆元的概念，即对于任意的a和n，如果存在一个正整数x，使得(a×x) mod n = 1，则称x为a在模n下的逆元，记为a^{-1}。如果n是质数，且a和n互质，则a在模n下一定存在逆元。

模运算是数论中的一个重要概念，用于处理循环和周期性的问题。模运算是指给定一个正整数 m，两个整数 a 和 b，如果它们相除后余数相同，我们就说 a 和 b 对模 m 同余。用数学符号表示为：a ≡ b (mod m)。

模运算的性质如下：

1.  反射性：对于任意整数 a 和正整数 m，a ≡ a (mod m)。
    
2.  对称性：对于任意整数 a 和 b，以及正整数 m，如果 a ≡ b (mod m)，那么 b ≡ a (mod m)。
    
3.  传递性：对于任意整数 a、b 和 c，以及正整数 m，如果 a ≡ b (mod m) 且 b ≡ c (mod m)，那么 a ≡ c (mod m)。
    
4.  加法性质：对于任意整数 a、b、c 和 d，以及正整数 m，如果 a ≡ b (mod m) 且 c ≡ d (mod m)，那么 a + c ≡ b + d (mod m)。
    
5.  乘法性质：对于任意整数 a、b、c 和 d，以及正整数 m，如果 a ≡ b (mod m) 且 c ≡ d (mod m)，那么 a \* c ≡ b \* d (mod m)。
    
6.  分配律：对于任意整数 a、b 和 c，以及正整数 m，有 (a + b) \* c ≡ (a \* c + b \* c) (mod m)。
    
7.  逆元：对于整数 a 和正整数 m，如果存在整数 a' 使得 a \* a' ≡ 1 (mod m)，那么 a' 称为 a 的模 m 乘法逆元。只有当 a 和 m 互质（即它们的最大公约数为 1）时，a 才存在模 m 乘法逆元。
    
8.  费马小定理：对于任意整数 a 和质数 p，如果 a 和 p 互质，那么 a^(p-1) ≡ 1 (mod p)。
    

模运算在计算机科学、密码学和数学等领域有广泛应用。例如，哈希函数、伪随机数生成器、加密算法（如 RSA 算法）等都使用了模运算的性质。

### 1. 欧几里得算法（Euclidean Algorithm）

**通俗解释：**
欧几里得算法是一种用来计算两个正整数的最大公因数（GCD，Greatest Common Divisor）的方法。它的核心思想是通过不断地将较大的数减去较小的数，直到两个数相等，这个相等的数就是它们的最大公因数。为了更高效，算法使用取模运算（取余数）来代替减法。

**详细示例：**

假设我们要计算 252 和 105 的最大公因数。

**步骤：**

1. **初始状态：**
    a = 252 
    b = 105 

2. **第一步：**
   计算  $252 \mod 105$ 
    $252 \div 105 = 2$  余数是 42（即  $252 = 105 \times 2 + 42$ ）
   替换  a  和  b ：现在  a = 105 ,  b = 42 

3. **第二步：**
   计算  $105 \mod 42$ 
    $105 \div 42 = 2$  余数是 21（即  $105 = 42 \times 2 + 21$ ）
   替换  a  和  b ：现在  a = 42 ,  b = 21 

4. **第三步：**
   计算  $42 \mod 21$
    42 \div 21 = 2  余数是 0（即  $42 = 21 \times 2 + 0$ ）
   替换  a  和  b ：现在  a = 21 ,  b = 0 

5. **结束：**
   因为  b = 0 ，所以最大公因数  $\text{gcd}(252, 105) = 21$ 。

### 2. 拓展欧几里得算法（Extended Euclidean Algorithm）

**通俗解释：**
拓展欧几里得算法不仅仅计算两个数的最大公因数，还可以找到一组整数解 x 和 y，使得 $ax + by = \text{gcd}(a, b)$。这个方法在许多数学和计算机科学的应用中非常重要，例如求模逆（modular inverse）。

**详细示例：**

假设我们要找到 252 和 105 的最大公因数，同时找到一组 x 和 y 满足 $252x + 105y = \text{gcd}(252, 105)$。

**步骤：**

1. **初始状态：**
    a = 252 
    b = 105 
   需要计算最大公因数  d  和系数  x  和  y 。

2. **使用欧几里得算法计算最大公因数：**
   - 252 除以 105 商 2 余 42
   - 105 除以 42 商 2 余 21
   - 42 除以 21 商 2 余 0
   最大公因数是 21。

3. **回溯计算系数  x  和  y ：**
   通过之前的计算步骤，我们可以逐步找到 x 和 y。
   
   先求出最后一步的系数（直接解）：
    $21 = 42 - 1 \cdot 21$
   
   替代上一步的计算：
    $21 = 42 - 1 \cdot (105 - 2 \cdot 42)$
    $21 = 3 \cdot 42 - 1 \cdot 105$
   
   再代入上一步的计算：
    $21 = 3 \cdot (252 - 2 \cdot 105) - 1 \cdot 105$
    $21 = 3 \cdot 252 - 7 \cdot 105$
   
   因此，我们得到  x = 3  和  y = -7 ，满足：
    $252 \cdot 3 + 105 \cdot (-7) = 21$

通过拓展欧几里得算法，我们不仅得到了最大公因数 21，还找到了使得 252x + 105y = 21 的整数解  x = 3 ， y = -7 。

### 总结

- **欧几里得算法**：通过不断取模计算两个数的最大公因数。
- **拓展欧几里得算法**：在求最大公因数的同时，找到使得 ax + by = \text{gcd}(a, b) 的整数解。

这些算法在数论、密码学和计算机科学中都有广泛的应用。


### 通俗版解释

要证明对于两个整数  a  和  b （其中  a > b \）），它们的最大公因数等于  b  和  a \mod b  的最大公因数，我们可以用一个简单的例子和逻辑推理来说明。

#### 例子：

假设  a = 27 ， b = 12 。

1. **计算  a \mod b **：
   
   a \mod b = 27 \mod 12 = 3
   
   所以我们要证明 \gcd(27, 12) = \gcd(12, 3)。

2. **寻找公因数**：
   - 27 和 12 的公因数有：1, 3
   - 12 和 3 的公因数有：1, 3

可以看到，这两个集合中的最大公因数都是 3。

#### 逻辑推理：

1. **定义最大公因数**：
   - 最大公因数（GCD）是能整除两个数的最大的整数。

2. **最大公因数的性质**：
   - 如果  d  是  a  和  b  的公因数，那么  d  也必须是  a  和  a - b \cdot q  的公因数，其中  q  是  a  除以  b  的商（整数部分）。

3. **通俗解释**：
   - 把  a  用  b  来分割，余数  r  就是  a \mod b 。
   - 假设  d  是  a  和  b  的最大公因数，那么  d  也必须是  b  和  a \mod b  的最大公因数。

### 严谨版解释

#### 定理：

对于任意两个正整数  a  和  b （假设  a > b ），我们有：

$\gcd(a, b) = \gcd(b, a \mod b)$


#### 证明：

1. **定义**：
   设  $d = \gcd(a, b)$ 。那么  d  是  a  和  b  的最大公因数。

2. **性质**：
   根据最大公因数的性质， d  同时整除  a  和  b 。我们可以表示为：
   $a = d \cdot m$
   $b = d \cdot n$
   其中  m  和  n  是整数。

3. **表达模运算**：
   根据  $a \mod b$  的定义，我们可以写成：
   
   $a \mod b = a - b \cdot q$
   
   其中  q  是  a  除以  b  的商的整数部分。

4. **代入最大公因数**：
   
   $a \mod b = d \cdot m - (d \cdot n) \cdot q$
   $a \mod b = d \cdot (m - n \cdot q)$
   
   这里， m - n \cdot q  也是整数，所以  d  也整除  a \mod b 。

5. **结论**：
   由此可得， d  既是  b  的公因数，也是  $a \mod b$  的公因数，因此：
   
   $d \leq \gcd(b, a \mod b)$
   

6. **反证法**：
   假设  d'  是  b  和  a \mod b  的最大公因数，那么  d'  也整除  a \mod b  和  b ，所以  d'  也整除  a 。因此：
   
   $d' \leq \gcd(a, b)$
   

7. **综合**：
   因此  d  和  d'  必须相等，即：
   
   \gcd(a, b) = \gcd(b, a \mod b)
   

通过这个证明，我们可以得出结论：两个整数  a  和  b （假设  a > b ）的最大公因数等于  b  和  a \mod b  的最大公因数。这就是欧几里得算法的数学基础。


### 欧几里得算法的数学原理

**欧几里得算法**是一种求解两个非负整数的最大公因数（GCD）的算法。它的原理基于以下两个重要性质：

1. **辗转相除法**：对于两个整数 a 和 b（假设 a > b），它们的最大公因数等于 b 和 a \mod b 的最大公因数，即：
   
   $\gcd(a, b) = \gcd(b, a \mod b)$
   
   其中，a \mod b 表示 a 除以 b 的余数。

2. **递归性质**：利用上述性质，可以递归地将问题规模缩小，直到其中一个数变为 0，此时另一个数就是最大公因数。

**公式推导**：

设有两个整数 a 和 b，且 a > b。根据辗转相除法，可以将 a 写成：

$a = b \cdot q + r$

其中，q 是商，r 是余数，即 0 \leq r < b。根据性质：

$\gcd(a, b) = \gcd(b, r)$

可以继续递归地应用此性质，直到余数 r = 0 时：

$\gcd(a, b) = \gcd(b, 0) = b$

**详细示例**：

计算 \gcd(252, 105) 的步骤如下：

1. 初始值：a = 252，b = 105
2. 第一步：计算 252 \mod 105 = 42
 更新值：a = 105，b = 42
4. 第二步：计算 105 \mod 42 = 21
 更新值：a = 42，b = 21
6. 第三步：计算 42 \mod 21 = 0
7. 结束条件：b = 0，最大公因数是 21。

### 拓展欧几里得算法的数学原理

**拓展欧几里得算法**（Extended Euclidean Algorithm）在计算最大公因数的同时，还能找到满足等式 $ax + by = \gcd(a, b)$ 的整数解 x 和 y。

**数学原理**：

1. **基本等式**：
   在每一步迭代中，设 d = \gcd(a, b)，那么有：
   
   d = ax + by
   
   其中 x 和 y 是某一步计算出的整数。

2. **递归关系**：
   在欧几里得算法的递归过程中，每一步都可以表示为：
   $\gcd(a, b) = \gcd(b, a \mod b)$
   设 $a = bq + r$，则有：
   $r = a - bq$
   因此：
   $\gcd(b, r) = \gcd(b, a - bq)$


3. **反向替换**：
   当递归结束时，回溯计算系数 x 和 y。假设在某一步得到：

   $d = b \cdot x_2 + (a \mod b) \cdot y_2$

   将 $a \mod b$ 替换为 $a - b \cdot \left\lfloor \frac{a}{b} \right\rfloor$：

$$   d = b \cdot x_2 + (a - b \cdot \left\lfloor \frac{a}{b} \right\rfloor) \cdot y_2$$

   化简得：

$$   d = a \cdot y_2 + b \cdot (x_2 - \left\lfloor \frac{a}{b} \right\rfloor \cdot y_2)$$

   因此，新的一步结果是：

   $x_1 = y_2$


$$   y_1 = x_2 - \left\lfloor \frac{a}{b} \right\rfloor \cdot y_2$$


**详细示例**：

继续使用之前的例子，计算 $\gcd(252, 105)$ 及其对应的系数 x 和 y。

1. 初始值：a = 252，b = 105
2. 第一步：

   $252 = 105 \cdot 2 + 42$

   $\gcd(252, 105) = \gcd(105, 42)$

   回溯时：$x_2 = 0，y_2 = 1$

3. 第二步：
   
   $105 = 42 \cdot 2 + 21$
   
   
   $\gcd(105, 42) = \gcd(42, 21)$
   
   回溯时：$x_2 = 1，y_2 = 0 - 2 \cdot 1 = -2$

4. 第三步：
   
   $42 = 21 \cdot 2 + 0$
   
   
   $\gcd(42, 21) = 21$
   
   回溯时：$x_2 = -2，y_2 = 1 - 2 \cdot (-2) = 5$

最终结果是：

$252 \cdot (-2) + 105 \cdot 5 = 21$


通过这些步骤，我们得到了系数 x = -2 和 y = 5，满足 252x + 105y = 21。

总结：
- **欧几里得算法**：用于计算最大公因数，通过不断取模递归缩小问题规模。
- **拓展欧几里得算法**：在计算最大公因数的同时，找到使得 ax + by = \gcd(a, b) 的整数解，通过回溯计算得到系数。
## 概念

- 大于1的自然数中，除了1和它本身以外，无法被其他自然数整除的数。
- 集合论的角度：若$p$是素数，则$p \in \mathbb{N}$ 且对于任意$a, b \in \mathbb{N}$，若$p = a \times b$，则$a = 1$或$b = 1$。
- 编程角度: 素数被定义为无法被2到其平方根之间的任何数整除的数。
#### 质数的性质

1.  除了2和3，所有质数都可以表示为 6k ± 1 的形式（k为正整数）。
    
2.  如果一个质数 p 不能整除一个整数 a，那么 a^(p-1) ≡ 1 (mod p)，这是费马小定理。
    
3.  质数有无穷多个，这是欧几里得证明的。
    
4.  对于任意整数 a 和质数 p，a^p ≡ a (mod p)，这是费马-欧拉定理的一个特例。


# 02. 公钥密码体制
公钥加密又称 **非对称加密** 。

在公钥密码体制中，加密密钥==不同于==解密密钥。加密密钥公开，而解密密钥私有（只有解密人自己知道）。它们分别称为 ==PK公开密钥== (Public key) 和 ==SK秘密密钥== (Secret key)。目前已经有许多非对称加密算法，如RSA算法、ECC算法等。

::: tip 现代密码学的一个基本原则
$$一切秘密都存在于密钥之中。$$
其含义是，在设计加密系统时，总是假设密码算法是公开的，真正需要保密的是密钥。这是因为密码算法相对密钥来说更容易泄漏。算法不需要保密的事实意味着制造商能够并已经开发了实现数据加密算法的低成本芯片，这些芯片可广泛使用并能与一些产品融为一体。对于加密算法的使用，主要的安全问题是维护其密钥的安全。
:::

## 1. 公钥密码数论基础
### 1. 整除性和带余除法
* **整除性**（Divisibility）
    * 设 $a,b$ 均为整数，若存在某个整数 $m$ 使得 $a=mb$ 成立，则称非零数 b **整除**（divides） a 。
    * 换言之，若 b 除 a 没有余数，则称 b 整除 a 。
    * b 整除 a 通常用 $b|a$ 来表示，b是a的一个==因子==。
* 整数整除的性质
    * 若 a|1，则 a=±1
    * 若 a|b 且 b|a ，则a=±b
    * 任何不等于零的数都整除0
    * 若 a|b 且 b|c ，则 a|c
    * 对任意整数m、n，若 b|g 且 b|h ，则$b|(mg+nh)$
* 带余除法
    * 对给定的任意一个正整数 $n$ 和任意整数 $a$ ，若用 $n$ 除 $a$ ，得到整数 $q$ 和整数余数 $r$ ，且满足以下关系式：
    $$a=qn+r,0≤r＜n,q=⌊a/n⌋$$
    $⌊x⌋$表示小于等于 $x$ 的最大整数
    * 对于负数a，n也成立。
    * ==**余数的符号和除数同号**==

:::col example
* 5 / 3
    * 5 = 3 * ⌊5/3⌋ + 2
    * 5 mod 3 = 2
* 5 / -3
    * 5 = -3 * ⌊5/-3⌋ - 1
    * 5 mod -3 = -1
* -5 / 3
    * -5 = 3 * ⌊-5/3⌋ + 1
    * -5 mod 3 = 1
* -5 / -3
    * -5 = -3 * ⌊-5/-3⌋ - 2
    * -5 mod -3 = -2
:::

### 2. 欧几里得算法
欧几里得算法可以快速的求出两个正整数的最大公因子（Greatest Common Divisor, gcd).
整数的最大公因子用gcd来表示，其可定义为：
#### 拓展欧几里得算法
欧几里得算法用于求取整数a,b的最大公因数gcd(a,b)，基于gcd(a,b)=gcd(b,a mod b)成立。拓展的欧几里得算法用于求取a*x+b*y=gcd(a,b)的整数解(x,y)。

```python
def extendgcd(a,b):            #返回一个集合：(x,y,d)满足ax+by=d
    if b == 0:
        return (1,0,a)
    else:
        (x,y,d)=extendgcd(b,a%b)
        x,y=y,(x-(a//b)*y)#x-(a//b)*y即为x mod y
        return (x,y,d)
```
当算法进行到最后一步，即 $a=d，b=0$ 时，必然有 $(x,y)=(1,0)$ 满足 $a*1+b*0=d$ 。此即为回溯的起始点。

考察回溯过程中上下两层的关系。有：
$$a * x1 + b * y1 = gcd(a,b)\\
b * x2 + (a\%b) * y2 = gcd(b,a\%b)$$

d= gcd(a,b) = gcd(b,a%b) 算法中每一步返回值都满足d=ax+by

得：a * x1 + b * y1 = b * x2 + (a%b) * y2
其中a%b换为a-(a/b)*b。
得：a * x1 + b * y1 = b * x2 + (a - (a / b) * b) * y2
                =b * (x2 - (a / b) * y2) + a * y2
                  =a * y2 + b * (x2 - (a / b) * y2)
得到：
X1=y2, y1=(x2 - (a / b) * y2)
得到方程b * x2 + (a%b) * y2 = g(b,a%b) 的解x2, y2，就能得到方程a * x1 + b * y1 = g(a,b) 的解x1,y1。


在RSA算法中，拓展欧几里得算法用于求取e的关于模φ(n)的逆元d。
即令e*d mod φ(n)=1，求d。 
令e*x+φ(n)*y=gcd(e,φ(n))=1          #φ(n)与e互质
该式正是拓展欧几里得算法公式。求取x。
等式两边同时模φ(n)，得e*x mod φ(n)=1。
即x就是我们要求的私钥d。


### 3. 模运算
模运算常用于计算离散数学中的 **同余** 关系。模运算也被称为取模运算，用符号 `%` 表示，其基本概念是在一个模数n的范围内对数进行运算。

对于给定的整数a和正整数n，模运算a mod n的结果是除法所得的余数。例如，17 mod 5等于2，因为17除以5的余数是2。

模运算有以下性质：

1.  加法的模运算满足结合律和交换律，即(a+b) mod n = ((a mod n) + (b mod n)) mod n，a mod n = b mod n，则(a+c) mod n = (b+c) mod n。
2.  减法的模运算满足结合律和交换律，即(a-b) mod n = ((a mod n) - (b mod n) + n) mod n，a mod n = b mod n，则(a-c) mod n = (b-c) mod n。
3.  乘法的模运算满足结合律和交换律，即(a×b) mod n = ((a mod n) × (b mod n)) mod n。
4.  除法的模运算不满足结合律和交换律，但是有除法的模逆元的概念，即对于任意的a和n，如果存在一个正整数x，使得(a×x) mod n = 1，则称x为a在模n下的逆元，记为a^{-1}。如果n是质数，且a和n互质，则a在模n下一定存在逆元。

模运算是数论中的一个重要概念，用于处理循环和周期性的问题。模运算是指给定一个正整数 m，两个整数 a 和 b，如果它们相除后余数相同，我们就说 a 和 b 对模 m 同余。用数学符号表示为：a ≡ b (mod m)。

模运算的性质如下：

1.  反射性：对于任意整数 a 和正整数 m，a ≡ a (mod m)。
    
2.  对称性：对于任意整数 a 和 b，以及正整数 m，如果 a ≡ b (mod m)，那么 b ≡ a (mod m)。
    
3.  传递性：对于任意整数 a、b 和 c，以及正整数 m，如果 a ≡ b (mod m) 且 b ≡ c (mod m)，那么 a ≡ c (mod m)。
    
4.  加法性质：对于任意整数 a、b、c 和 d，以及正整数 m，如果 a ≡ b (mod m) 且 c ≡ d (mod m)，那么 a + c ≡ b + d (mod m)。
    
5.  乘法性质：对于任意整数 a、b、c 和 d，以及正整数 m，如果 a ≡ b (mod m) 且 c ≡ d (mod m)，那么 a \* c ≡ b \* d (mod m)。
    
6.  分配律：对于任意整数 a、b 和 c，以及正整数 m，有 (a + b) \* c ≡ (a \* c + b \* c) (mod m)。
    
7.  逆元：对于整数 a 和正整数 m，如果存在整数 a' 使得 a \* a' ≡ 1 (mod m)，那么 a' 称为 a 的模 m 乘法逆元。只有当 a 和 m 互质（即它们的最大公约数为 1）时，a 才存在模 m 乘法逆元。
    
8.  费马小定理：对于任意整数 a 和质数 p，如果 a 和 p 互质，那么 a^(p-1) ≡ 1 (mod p)。
    

模运算在计算机科学、密码学和数学等领域有广泛应用。例如，哈希函数、伪随机数生成器、加密算法（如 RSA 算法）等都使用了模运算的性质。

### 4. 质数（素数）

质数：大于1的自然数中，除了1和它本身以外，无法被其他自然数整除的数。

#### 质数的性质

1.  除了2和3，所有质数都可以表示为 6k ± 1 的形式（k为正整数）。
    
2.  如果一个质数 p 不能整除一个整数 a，那么 a^(p-1) ≡ 1 (mod p)，这是费马小定理。
    
3.  质数有无穷多个，这是欧几里得证明的。
    
4.  对于任意整数 a 和质数 p，a^p ≡ a (mod p)，这是费马-欧拉定理的一个特例。

#### 质数在密码学和数论中的应用：

1.  RSA加密算法：RSA是一种广泛应用的非对称加密算法，其安全性依赖于大数分解问题的困难性。在RSA算法中，需要选取两个大质数 p 和 q，并计算它们的乘积 n = p \* q。n 的构造使得其分解变得非常困难，这就为RSA算法提供了安全保障。
    
2.  素性检测：在计算机科学中，素性检测是确定一个给定数是否为质数的过程。许多密码学应用和算法，如RSA，需要生成大质数。在这些情况下，高效的素性检测算法非常重要。
    
3.  模运算与同余方程：质数在模运算和同余方程中起着关键作用。质数作为模数具有许多有趣的性质，如费马小定理和欧拉定理等。这些性质在密码学和数论问题中具有广泛应用，如中国剩余定理、离散对数问题等。
    
4.  Diffie-Hellman密钥交换：Diffie-Hellman协议是一种密钥交换协议，允许双方在不安全的通信渠道上建立共享密钥。该协议使用质数和模运算，利用离散对数问题的困难性来保证安全性。
    

质数在密码学和数论中具有重要地位，它们的性质被用于构建许多加密算法和理论。

### 5. 费马定理与欧拉定理

## RSA算法
RSA算法是目前应用最为广泛的公钥密码算法。

### 数学证明

1. 选取两个足够大的质数 $p、q$。计算p与q的乘积为$n=pq$。
2. 再由p和q算出另一个数 $z=(p-1)(q-1)$，该数即欧拉函数值。
3. 然后再选取一个与z互素的奇数e，称e为公开指数；从这个e值可以找出另一个值d，并能满足e×d=1 mod (z)条件。
4. 由此而得到的两组数(n，e) 和 (n，d)分别被称为公开密钥和秘密密钥，或简称公钥和私钥。
5. 对于明文M，用公钥 (n，e) 加密可得到密文C。
C = M mod (n)     (1)
6. 对于密文C，用私钥(n，d)解密可得到明文M。
M = C mod (n)     (2)

(2) 式的数学证明用到了数论中的欧拉定理，具体过程这里不赘述。

### the answer of GPT
首先，我们需要选择两个足够大的质数 $p$ 和 $q$，计算它们的乘积 $n=pq$，$n$ 就是我们的模数。接下来，选择一个小于 $n$ 的整数 $e$，它要求与 $(p-1)(q-1)$ 互质，这里 $(p-1)(q-1)$ 就是欧拉函数的值。$e$ 称为加密指数，它是我们的公钥中的一部分。然后，我们需要找到一个整数 $d$，满足 $ed \equiv 1 \pmod{(p-1)(q-1)}$，$d$ 称为解密指数，它是我们的私钥中的一部分。

在加密时，我们需要将明文转换成一个数字 $m$，$m$ 不能大于模数 $n$，然后计算密文 $c=m^e \pmod n$，$c$ 就是加密后的密文。

在解密时，我们只需要用私钥中的解密指数 $d$ 对密文 $c$ 进行解密即可，计算出明文 $m=c^d \pmod n$。

RSA加密的安全性基于大数分解难题，也就是将一个大数分解成两个质数的乘积的难度。因为在实际应用中，我们会选择非常大的质数，其乘积的位数可能有几百位或者几千位，因此在当前的计算能力下，分解这个数是非常困难的。

### python实现RSA加密

该算法可分为以下几个步骤：

1. 密钥产生：
    * 选取两个大质数：$p,q$ 。

    * 计算模 $n=p*q$
    * 用欧拉函数计算$φ(n)=(p-1)(q-1)$
    * 获取公钥e。e需要满足：
        * $1<e<φ(n)$.
        * $gcd(φ(n),e)=1$.
    * 计算私钥 $d$ 。$d$ 需要满足:
    $d*e mod(φ(n))=1$.
    即 $d$ 为 $e$ 关于模 $φ(n)$ 运算的逆元。

2. 加密：$c=m^e \space mod \space n$

3. 解密：$m=c^d \space mod \space n$

```python
#--run--
# python实现RSA加密

```

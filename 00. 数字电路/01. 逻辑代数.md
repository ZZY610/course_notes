# 逻辑代数

## 逻辑变量

逻辑变量是用来表示逻辑状态的变量，通常用 0 和 1 表示逻辑值。

逻辑变量可以用来表示开关状态、传输信号、逻辑运算结果等。

## 逻辑运算

1. 逻辑 **与**（AND）：符号包括 `&` `∧` `·`（点号），表示所有输入变量都为真时，输出变量才为真。

```
Y = A & B = A∧B = A*B = AB
```

| A | B | Y |
|---|---|---|
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |
{.small}

2. 逻辑 **或**（OR）：符号 `|` `∨` `+`（加号），表示至少一个输入变量为真时，输出变量为真。

```
Y = A∨B = A+B
```

| A | B | Y |
|---|---|---|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 1 |
{.small}

3. 逻辑 **非**（NOT）：符号 `¬` 或 `!`（感叹号），表示对输入变量进行取反操作。

```
Y = ¬A = !A
```

| A | Y |
|---|---|
| 0 | 1 |
| 1 | 0 |
{.small}

4. **与非**（NAND）：和 **逻辑与**（AND）运算相反，符号 `↑` 表示，表示当所有输入变量都为真时，输出变量为假。

```
# 先与后非
Y = ¬(A*B) = ¬A + ¬B
```

| A | B | Y |
|---|---|---|
| 0 | 0 | 1 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |
{.small}

5. **或非**（NOR）：和 **逻辑或**（OR）运算相反，符号 `↓` 表示，表示当至少一个输入变量为真时，输出变量为假。

```
# 先或后非
Y = ¬(A+B)
```
| A | B | Y |
|---|---|---|
| 0 | 0 | 1 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 0 |

1. 异或（XOR）：符号 `⊕` ，表示两个输入变量相同时输出变量为假，两个输入变量不同时输出变量为真。
A xor B = A!B+!AB

| A | B | Y |
|---|---|---|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

7. 同或（XNOR）：符号 `⊙` ，表示两个输入变量相同时输出变量为真，两个输入变量不同时输出变量为假。
A xnor B = AB + !A!B

| A | B | Y |
|---|---|---|
| 0 | 0 | 1 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

8. 与或非（AND/OR/NOT）：符号 `AON` ，表示先进行逻辑与（AND）运算，然后对结果进行逻辑或（OR）运算，最后取反（NOT）。

9. 或与非（OR/AND/NOT）：符号 `OAN` ，表示先进行逻辑或（OR）运算，然后对结果进行逻辑与（AND）运算，最后取反（NOT）。

## 逻辑表达式
### 1. 什么是逻辑表达式？

逻辑表达式是由逻辑运算符和变量组成的表达式，用来描述特定条件或规则的真假关系。在逻辑表达式中，变量通常是布尔型变量，即只能取值为“真”（True）或“假”（False）。通过布尔代数中的运算符，如**与（AND）**、**或（OR）**、**非（NOT）**，我们可以将这些变量组合在一起，形成一个复杂的表达式。

### 2. 逻辑表达式与离散数学的关系

逻辑表达式是离散数学的重要组成部分。离散数学研究的是离散结构，例如集合、图、逻辑等。布尔代数是离散数学中的一部分，它提供了操作逻辑值的工具和方法。逻辑表达式在离散数学中用于推理、证明和计算，特别是对逻辑电路设计、计算机算法和程序逻辑等领域起到了基础性作用。

### 3. 逻辑表达式与数字电路的关系

数字电路实际上是逻辑表达式的物理实现。数字电路使用**逻辑门logic gates**来执行布尔代数操作，而逻辑门正是由逻辑表达式来描述的。因此，设计一个数字电路就是设计一组执行特定逻辑表达式的电路。

- **与门（AND）**: 输入为A和B，输出为 （A AND B）。
- **或门（OR）**: 输入为A和B，输出为（A OR B）。
- **非门（NOT）**: 输入为A，输出为（NOT A）。
- **异或门（XOR）**: 输入为A和B，输出为（A XOR B）。

### 4. 逻辑表达式在数字电路中的应用

在数字电路中，逻辑表达式用于描述电路的功能。设计人员通过简化逻辑表达式，找到最有效的逻辑门组合，从而优化电路的性能。布尔代数的运算规则，如结合律、交换律、分配律和德摩根定律，常用于简化这些表达式。

**例子：全加器**
全加器是用于加法运算的基本单元，它可以通过逻辑表达式来描述。假设有两个输入位  A  和  B  以及一个进位输入  $C_{in}$ ，它的和输出  S  和进位输出  $C_{out}$  的逻辑表达式如下：
-  $S = (A \oplus B) \oplus C_{in}$  （异或实现的加法）
-  $C_{out} = (A \land B) \lor (C_{in} \land (A \oplus B))$

这正是通过逻辑表达式来描述数字电路的运作方式。

### 5. 逻辑表达式的简化

复杂的逻辑表达式可以通过应用布尔代数的规则进行简化。

常用的简化规则包括：
- **结合律**:  $A \land (B \land C) = (A \land B) \land C$ 
- **交换律**:  $A \land B = B \land A$ 
- **分配律**:  $A \land (B \lor C) = (A \land B) \lor (A \land C)$ 
- **德摩根定律**:  $\lnot (A \land B) = \lnot A \lor \lnot B$ 

### 6. 逻辑表达式如何处理信息？

逻辑门可以处理和存储信息的关键在于它们能够基于输入状态产生输出，并通过反馈机制（如触发器或寄存器）保持和更新状态。例如，存储器件可以通过一个时钟信号和逻辑门网络来保存和修改二进制数值。逻辑门不仅能进行运算，还能通过组合和时序设计处理数据的传输和存储。

逻辑表达式是数字电路的理论基础，而数字电路则是逻辑表达式的物理实现。通过组合不同的逻辑门，我们可以设计出能够执行各种任务的电路系统，例如计算器、加法器、存储器等。

## 逻辑运算的规律（公式与定理）
逻辑运算的基本规律是构成数字电路和逻辑表达式的基础。以下是一些主要的逻辑运算规律：


:::: row
::: col 交换律
- **逻辑与（AND）**:  A * B = B * A 
- **逻辑或（OR）**:  A + B = B + A 
- 逻辑异或：A⊕B = B⊕A
:::
::: col 结合律
- **逻辑与**:  (A * B) * C = A * (B * C) 
- **逻辑或**:  (A + B) + C = A + (B + C) 
- 逻辑异或： (A⊕B)⊕C = A⊕(B⊕C)
:::
::: col 分配律
-  A * (B + C) = (A * B) + (A * C) 
-  A + (B * C) = (A + B) * (A + C) 
:::
::::
:::: row
::: col 身份律
- **逻辑与**:  A * 1 = A 
- **逻辑或**:  A + 0 = A 
- 逻辑异或： A⊕1 = !A，A⊕0 = A 
:::
::: col 零一律
- **逻辑与**:  A * 0 = 0 
- **逻辑或**:  A + 1 = 1 
- 逻辑异或： A⊕A = 0，A⊕!A = 1 
:::
::: col 否定律（互补律）
-  A * !A = 0 
-  A + !A = 1 
-  !!A = A 
:::
::: col 重叠律（幂等律）
- A + A = A
- A * A = A
:::
::::

::::row
::: col 德摩根律（反演率）
- !( A + B ) = !A * !B
- !( A * B ) = !A + !B
:::
::: col 吸收率
- A + A * B = A
- A *（ A + B ）= A
- A + !A * B = A + B
- A * (!A + B) = A * B
- A * B + A * !B = A
:::
::: col 包含率
- A * B + !A * C + B*C= A * B + !A * C
:::
::::

### 逻辑公式的推导

我们来看这些吸收律公式的推导过程，这些公式基于布尔代数的基本定律和逻辑运算的性质，包括结合律、分配律、双重否定律、补律等。
#### 吸收律
##### A + A * B = A 
推导过程：
- 根据分配律，我们可以将左边拆解为  A * (1 + B) ，因为  A = A * 1 。
- 因为  1 + B = 1 （任何布尔变量与1的或运算结果为1），我们可以将式子化简为  A * 1 。
- 最终， A * 1 = A ，所以  A + A * B = A 。

##### A * (A + B) = A 
推导过程：
- 我们可以使用分配律将  A * (A + B)  展开为  (A * A) + (A * B) 。
- 根据幂等律， A * A = A ，因此式子变为  A + A * B 。
- 使用第一个吸收律  A + A * B = A ，可以进一步得出  A * (A + B) = A 。

##### A + ! A * B = A + B 
推导过程：
- 我们可以使用分配律将  A + ! A * B  拆分为  (A + ! A) * (A + B) 。
- 根据补律， A + ! A = 1 ，所以式子变成  1 * (A + B) 。
- 最终， 1 * (A + B) = A + B ，因此  A + ! A * B = A + B 。

##### A * (! A + B) = A * B 
推导过程：
- 根据分配律，将  A * (! A + B)  展开为  (A * ! A) + (A * B) 。
- 根据补律， A * ! A = 0 ，所以式子变成  0 + A * B 。
- 因此，最终结果为  A * B ，所以  A * (! A + B) = A * B 。

##### A * B + A * ! B = A 
推导过程：
- 我们可以使用分配律将  A * B + A * ! B  写成  A * (B + ! B) 。
- 根据补律， B + ! B = 1 ，因此式子化简为  A * 1 。
- 最终结果为  A ，所以  A * B + A * ! B = A 。

#### 德摩根律
德摩根律是逻辑代数中的重要法则，用于描述逻辑表达式的取反操作。德摩根律的两个基本公式如下：

1. ! (A + B) = ! A * ! B
2. ! (A * B) = ! A + ! B

我们可以通过逻辑代数的基本公式来推导这两个定律。

---

##### 1. 推导第一个德摩根律公式：! (A + B) = ! A * ! B

1. **应用恒等律**：假设原表达式 ! (A + B)。
2. 根据定义，表达式中的! (A + B)的意思是 **“不是 A 或 B”**。这意味着 A 和 B 都为假，才能使 ! (A + B) 为真。
3. 若 A 为假，则 ! A 为真；同理若 B 为假，则 ! B 也为真。
4. 由此得出 ! A * ! B 代表 ! (A + B)，证明了第一个公式。

---

##### 2. 推导第二个德摩根律公式：! (A * B) = ! A + ! B

1. **应用恒等律**：假设原表达式 ! (A * B)。
2. 根据定义，表达式中的 ! (A * B) 的意思是 **“不是 A 和 B”**。即当 A 和 B 不同时为真时，表达式才为真。
3. 若 A 为假，或 B 为假（或二者皆假），则 ! (A * B) 为真。
4. 因此，可以表示为 ! A + ! B，证明了第二个公式。

这两个定律在逻辑电路和编程中的取反运算中具有广泛应用，是逻辑表达式化简与求解的基础。

## 三大定理

### **代入定理**
在任何一个包含变量A的逻辑等式中，若以另外 一个逻辑式 代入式中所有A的位置，则等式仍然成立。

代入定理说明，如果一个逻辑表达式中的每个变量被替换为某个表达式（可以是另一个变量或表达式），那么新生成的表达式仍然遵循相同的逻辑运算规则。  

如果    
$$F(A, B) = A + B$$

则 
$$F(\neg A, B \cdot C) = \neg A + (B \cdot C)$$ 
也成立。

### **反演定理**
对任意一个逻辑式Y，若将其中所有的“·”换成“+”， “+”换 成“·”， 0换成1， 1换成0，原变量换成反变量，反变量换成原变量，则得到的结果就是!Y。

::: tip 
（1）遵守原Y式中“先括号、再乘、后加”的运算次序
（2）不属于单个变量上的反号应保留不变
:::


反演定理指出，如果一个逻辑表达式中的所有变量和运算符都取反，则该表达式的输出结果也会取反。  

$$F(A, B) = A \cdot B + \neg A \cdot \neg B$$ 
其反演表达式是 
$$\neg A + \neg B \cdot A \cdot B$$

### **对偶定理**
对偶定理表明，对于任何逻辑表达式，将所有的与运算换成或运算，所有的或运算换成与运算，同时将 0 换成 1，1 换成 0，得到的表达式称为原表达式的对偶。  
$$ F(A, B) = A \cdot B + 0 $$
其对偶为 
$$ F(A, B) = A + B \cdot 1 $$
